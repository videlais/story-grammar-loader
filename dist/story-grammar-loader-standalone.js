!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.StoryGrammarLoader=t():e.StoryGrammarLoader=t()}(this,()=>(()=>{"use strict";var e={d:(t,r)=>{for(var i in r)e.o(r,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:r[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{JSONGrammarLoader:()=>i,KeywordRuleBuilder:()=>s,Parser:()=>r,createGrammarLoader:()=>n});class r{constructor(){this.grammar={},this.functionRules=new Map,this.weightedRules=new Map,this.conditionalRules=new Map,this.sequentialRules=new Map,this.rangeRules=new Map,this.templateRules=new Map,this.referenceValues=new Map,this.modifiers=new Map,this.variablePattern=/%([^%]+)%/g,this.maxDepth=100,this.randomSeed=null,this.currentSeed=0,this.currentContext={}}addRule(e,t){if(!e||"string"!=typeof e)throw new Error("Key must be a non-empty string");if(!Array.isArray(t))throw new Error("Values must be an array");this.grammar[e]=[...t]}addRules(e){for(const[t,r]of Object.entries(e))this.addRule(t,r)}addFunctionRule(e,t){if(!e||"string"!=typeof e)throw new Error("Key must be a non-empty string");if("function"!=typeof t)throw new Error("Value must be a function");this.functionRules.set(e,t)}removeFunctionRule(e){return this.functionRules.delete(e)}hasFunctionRule(e){return this.functionRules.has(e)}clearFunctionRules(){this.functionRules.clear()}addWeightedRule(e,t,r){if(!e||"string"!=typeof e)throw new Error("Key must be a non-empty string");if(!Array.isArray(t))throw new Error("Values must be an array");if(!Array.isArray(r))throw new Error("Weights must be an array");if(t.length!==r.length)throw new Error("Values and weights arrays must have the same length");if(0===t.length)throw new Error("Values array cannot be empty");for(const e of r)if("number"!=typeof e||e<0)throw new Error("All weights must be non-negative numbers");const i=r.reduce((e,t)=>e+t,0);if(Math.abs(i-1)>1e-4)throw new Error(`Weights must sum to 1.0, but sum to ${i}`);const s=[];let n=0;for(const e of r)n+=e,s.push(n);this.weightedRules.set(e,{values:[...t],weights:[...r],cumulativeWeights:s})}removeWeightedRule(e){return this.weightedRules.delete(e)}hasWeightedRule(e){return this.weightedRules.has(e)}clearWeightedRules(){this.weightedRules.clear()}addConditionalRule(e,t){if(!e||"string"!=typeof e)throw new Error("Key must be a non-empty string");if(!t||!Array.isArray(t.conditions))throw new Error("Rule must have a conditions array");if(0===t.conditions.length)throw new Error("Conditions array cannot be empty");let r=!1;for(const e of t.conditions)if("default"in e){if(r)throw new Error("Only one default condition is allowed");if(r=!0,!Array.isArray(e.default))throw new Error("Default condition must have an array of values")}else{if(!("if"in e)||!("then"in e))throw new Error('Each condition must have either "if/then" or "default"');if("function"!=typeof e.if)throw new Error('Condition "if" must be a function');if(!Array.isArray(e.then))throw new Error('Condition "then" must be an array of values')}this.conditionalRules.set(e,{conditions:t.conditions.map(e=>({...e}))})}addSequentialRule(e,t,r={cycle:!0}){if(!e||"string"!=typeof e)throw new Error("Key must be a non-empty string");if(!Array.isArray(t)||0===t.length)throw new Error("Values must be a non-empty array");this.sequentialRules.set(e,{values:[...t],index:0,cycle:r.cycle})}addRangeRule(e,t){if(!e||"string"!=typeof e)throw new Error("Key must be a non-empty string");if("number"!=typeof t.min||"number"!=typeof t.max)throw new Error("Min and max must be numbers");if(t.min>=t.max)throw new Error("Min must be less than max");if(void 0!==t.step&&("number"!=typeof t.step||t.step<=0))throw new Error("Step must be a positive number");if(!["integer","float"].includes(t.type))throw new Error('Type must be "integer" or "float"');this.rangeRules.set(e,{min:t.min,max:t.max,step:t.step,type:t.type})}addTemplateRule(e,t){if(!e||"string"!=typeof e)throw new Error("Key must be a non-empty string");if(!t.template||"string"!=typeof t.template)throw new Error("Template must be a non-empty string");if(!t.variables||"object"!=typeof t.variables)throw new Error("Variables must be an object");const r=this.findVariables(t.template);for(const e of r){if(!(e in t.variables))throw new Error(`Template variable '${e}' not found in variables object`);if(!Array.isArray(t.variables[e]))throw new Error(`Variable '${e}' must be an array`)}this.templateRules.set(e,{template:t.template,variables:{...t.variables}})}removeConditionalRule(e){return this.conditionalRules.delete(e)}removeSequentialRule(e){return this.sequentialRules.delete(e)}removeRangeRule(e){return this.rangeRules.delete(e)}removeTemplateRule(e){return this.templateRules.delete(e)}hasConditionalRule(e){return this.conditionalRules.has(e)}hasSequentialRule(e){return this.sequentialRules.has(e)}hasRangeRule(e){return this.rangeRules.has(e)}hasTemplateRule(e){return this.templateRules.has(e)}clearConditionalRules(){this.conditionalRules.clear()}clearSequentialRules(){this.sequentialRules.clear()}clearRangeRules(){this.rangeRules.clear()}clearTemplateRules(){this.templateRules.clear()}resetSequentialRule(e){const t=this.sequentialRules.get(e);return!!t&&(t.index=0,!0)}addModifier(e){if(!e||"object"!=typeof e)throw new Error("Modifier must be an object");if(!e.name||"string"!=typeof e.name)throw new Error("Modifier must have a name");if("function"!=typeof e.condition)throw new Error("Modifier must have a condition function");if("function"!=typeof e.transform)throw new Error("Modifier must have a transform function");this.modifiers.set(e.name,{...e,priority:e.priority??0})}removeModifier(e){return this.modifiers.delete(e)}hasModifier(e){return this.modifiers.has(e)}getModifiers(){return Array.from(this.modifiers.values()).sort((e,t)=>(t.priority??0)-(e.priority??0))}loadModifier(e){this.addModifier(e)}loadModifiers(e){for(const t of e)this.addModifier(t)}getGrammar(){const e={};for(const[t,r]of Object.entries(this.grammar))e[t]=[...r];return e}parse(e,t=!1){if("string"!=typeof e)throw new Error("Text must be a string");t||(this.currentContext={},this.referenceValues.clear());const r=this.expandVariables(e,0);return this.applyModifiers(r,{originalText:e})}parseWithTiming(e,t=!1){const r=Date.now();if("string"!=typeof e)throw new Error("Text must be a string");t||(this.currentContext={},this.referenceValues.clear());const i=Date.now(),s=this.expandVariables(e,0),n=Date.now(),a=Date.now(),o=this.applyModifiers(s,{originalText:e}),l=Date.now();return{result:o,timing:{totalMs:Date.now()-r,expansionMs:n-i,modifierMs:l-a}}}expandVariables(e,t){if(t>=this.maxDepth)throw new Error("Maximum recursion depth exceeded. Check for circular references in grammar.");return this.variablePattern.lastIndex=0,e.replace(this.variablePattern,(e,r)=>{let i;if(r.startsWith("@")){const t=r.substring(1),i=this.referenceValues.get(t);return void 0!==i?i:e}const s=this.functionRules.get(r);if(s)try{const t=s();if(!Array.isArray(t))throw new Error(`Function rule '${r}' must return an array`);if(0===t.length)return e;i=this.getRandomValue(t)}catch(e){throw new Error(`Error executing function rule '${r}': ${e instanceof Error?e.message:String(e)}`)}else{const t=this.conditionalRules.get(r);if(t)i=this.getConditionalValue(t);else{const t=this.sequentialRules.get(r);if(t)i=this.getSequentialValue(t);else{const t=this.rangeRules.get(r);if(t)i=this.getRangeValue(t);else{const t=this.templateRules.get(r);if(t)i=this.getTemplateValue(t);else{const t=this.weightedRules.get(r);if(t)i=this.getWeightedRandomValue(t);else{const t=this.grammar[r];if(!t||0===t.length)return e;i=this.getRandomValue(t)}}}}}}return this.referenceValues.set(r,i),this.currentContext[r]=i,this.expandVariables(i,t+1)})}applyModifiers(e,t){let r=e;const i=this.getModifiers();for(const e of i)e.condition(r,t)&&(r=e.transform(r,t));return r}getConditionalValue(e){for(const t of e.conditions)if("if"in t&&t.if&&t.then){if(t.if(this.currentContext))return this.getRandomValue(t.then)}else if("default"in t&&t.default)return this.getRandomValue(t.default);throw new Error("No matching condition found and no default provided")}getSequentialValue(e){if(e.index>=e.values.length){if(!e.cycle)return e.values[e.values.length-1];e.index=0}const t=e.values[e.index];return e.index++,t}getRangeValue(e){const{min:t,max:r,step:i,type:s}=e;if(void 0!==i){const e=Math.floor((r-t)/i),n=t+Math.floor(this.getSeededRandom()*(e+1))*i;return"integer"===s?Math.round(n).toString():n.toString()}{const e=t+this.getSeededRandom()*(r-t);return"integer"===s?Math.floor(e).toString():e.toString()}}getTemplateValue(e){const t={...this.currentContext};let r=e.template;const i=this.findVariables(r);for(const s of i)if(s in e.variables){const i=this.getRandomValue(e.variables[s]);r=r.replace(new RegExp(`%${s}%`,"g"),i),t[s]=i}return r}getSeededRandom(){return null===this.randomSeed?Math.random():(this.currentSeed=1664525*this.currentSeed+1013904223>>>0,this.currentSeed/4294967296)}getRandomValue(e){return e[Math.floor(this.getSeededRandom()*e.length)]}getWeightedRandomValue(e){const t=this.getSeededRandom();for(let r=0;r<e.cumulativeWeights.length;r++)if(t<=e.cumulativeWeights[r])return e.values[r];return e.values[e.values.length-1]}hasRule(e){return this.functionRules.has(e)||this.conditionalRules.has(e)||this.sequentialRules.has(e)||this.rangeRules.has(e)||this.templateRules.has(e)||this.weightedRules.has(e)||e in this.grammar}removeRule(e){const t=this.functionRules.delete(e),r=this.conditionalRules.delete(e),i=this.sequentialRules.delete(e),s=this.rangeRules.delete(e),n=this.templateRules.delete(e),a=this.weightedRules.delete(e),o=e in this.grammar&&(delete this.grammar[e],!0);return t||r||i||s||n||a||o}clear(){this.grammar={},this.functionRules.clear(),this.conditionalRules.clear(),this.sequentialRules.clear(),this.rangeRules.clear(),this.templateRules.clear(),this.weightedRules.clear(),this.referenceValues.clear(),this.currentContext={}}clearModifiers(){this.modifiers.clear()}clearAll(){this.clear(),this.clearModifiers()}findVariables(e){const t=new Set;let r;for(this.variablePattern.lastIndex=0;null!==(r=this.variablePattern.exec(e));)t.add(r[1]);return Array.from(t)}validate(){const e=new Set,t=new Set,r=[],i=new Set,s=[];for(const[n,a]of Object.entries(this.grammar))if(a&&0!==a.length)for(const r of a){if(!r||"string"!=typeof r){s.push(`Rule '${n}' contains non-string value`);continue}const a=this.findVariables(r);for(const r of a)r.startsWith("@")||(i.add(r),this.hasRule(r)||e.add(r),r===n&&t.add(n))}else r.push(n);const n=new Set([...Object.keys(this.grammar),...Array.from(this.functionRules.keys()),...Array.from(this.weightedRules.keys()),...Array.from(this.conditionalRules.keys()),...Array.from(this.sequentialRules.keys()),...Array.from(this.rangeRules.keys()),...Array.from(this.templateRules.keys())]),a=Array.from(n).filter(e=>!i.has(e));return 0===this.modifiers.size&&s.push("No modifiers configured - consider adding English modifiers for better text quality"),0===Object.keys(this.grammar).length&&0===n.size&&s.push("No rules defined"),{isValid:0===e.size&&0===t.size&&0===r.length,missingRules:Array.from(e),circularReferences:Array.from(t),emptyRules:r,unreachableRules:a,warnings:s}}safeParse(e,t={}){const{preserveContext:r=!1,validateFirst:i=!0,maxAttempts:s=3}=t;try{if(i){const e=this.validate();if(!e.isValid)return{success:!1,error:`Validation failed: ${e.missingRules.length} missing rules, ${e.circularReferences.length} circular references`,validation:e}}let t=null;for(let i=1;i<=s;i++)try{return{success:!0,result:this.parse(e,r),attempts:i}}catch(n){if(t=n instanceof Error?n:new Error(String(n)),t.message.includes("recursion")&&i<s){const t=this.maxDepth;this.setMaxDepth(Math.max(10,Math.floor(t/2)));try{const s=this.parse(e,r);return this.setMaxDepth(t),{success:!0,result:s,attempts:i}}catch{this.setMaxDepth(t)}}}return{success:!1,error:t?.message||"Unknown parsing error",attempts:s}}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e)}}}setMaxDepth(e){if(e<1)throw new Error("Max depth must be at least 1");this.maxDepth=e}getMaxDepth(){return this.maxDepth}setRandomSeed(e){if("number"!=typeof e||!Number.isInteger(e))throw new Error("Seed must be an integer");this.randomSeed=Math.abs(e)>>>0,this.currentSeed=this.randomSeed}clearRandomSeed(){this.randomSeed=null,this.currentSeed=0}getRandomSeed(){return this.randomSeed}clearReferences(){this.referenceValues.clear(),this.currentContext={}}getContext(){return{...this.currentContext}}parseBatch(e,t=!0){if(!Array.isArray(e))throw new Error("Texts must be an array");const r=[];for(let i=0;i<e.length;i++){const s=t&&i>0;r.push(this.parse(e[i],s))}return r}generateVariations(e,t,r){if("string"!=typeof e)throw new Error("Text must be a string");if(!Number.isInteger(t)||t<1)throw new Error("Count must be a positive integer");const i=this.getRandomSeed(),s=[];try{for(let i=0;i<t;i++)void 0!==r&&this.setRandomSeed(r+i),s.push(this.parse(e,!1))}finally{null!==i?this.setRandomSeed(i):this.clearRandomSeed()}return s}getStats(){return{totalRules:Object.keys(this.grammar).length+this.functionRules.size+this.weightedRules.size+this.conditionalRules.size+this.sequentialRules.size+this.rangeRules.size+this.templateRules.size,rulesByType:{static:Object.keys(this.grammar).length,function:this.functionRules.size,weighted:this.weightedRules.size,conditional:this.conditionalRules.size,sequential:this.sequentialRules.size,range:this.rangeRules.size,template:this.templateRules.size},totalModifiers:this.modifiers.size,maxDepth:this.maxDepth,hasRandomSeed:null!==this.randomSeed}}exportConfig(){return{grammar:this.getGrammar(),modifiers:Array.from(this.modifiers.keys()),settings:{maxDepth:this.maxDepth,randomSeed:this.randomSeed}}}clone(){const e=new r;return e.addRules(this.getGrammar()),e.setMaxDepth(this.maxDepth),null!==this.randomSeed&&e.setRandomSeed(this.randomSeed),e}optimize(){const e=[],t=[],r=this.getStats();r.totalRules>1e3&&e.push(`Large number of rules (${r.totalRules}). Consider grouping related rules.`),r.totalModifiers>10&&e.push(`Many modifiers (${r.totalModifiers}). High-priority modifiers run first.`),r.maxDepth>20&&t.push("Consider reducing max depth for better performance.");const i=new Set;for(const e of Object.values(this.grammar))for(const t of e)this.findVariables(t).forEach(e=>i.add(e));const s=Object.keys(this.grammar).filter(e=>!i.has(e));return s.length>0&&t.push(`Consider removing unused rules: ${s.slice(0,5).join(", ")}${s.length>5?"...":""}`),{warnings:e,suggestions:t,optimized:0===e.length&&0===t.length}}analyzeRules(e){const t=[],r=[];for(const[t,i]of Object.entries(this.grammar)){if(e&&t!==e)continue;let s=0;const n=new Set;for(const e of i){const t=this.findVariables(e);t.forEach(e=>n.add(e)),s+=t.length+(e.length>50?2:0)}if(r.push({name:t,complexity:s,type:"static"}),e===t)return{totalComplexity:s,averageDepth:this.calculateRuleDepth(t),mostComplex:[t],suggestions:s>10?["Consider splitting complex rule into smaller rules"]:[],ruleDetails:{name:t,type:"static",complexity:s,variables:Array.from(n),depth:this.calculateRuleDepth(t)}}}this.functionRules.forEach((t,i)=>{e&&i!==e||r.push({name:i,complexity:5,type:"function"})}),this.weightedRules.forEach((t,i)=>{if(!e||i===e){const e=2*t.values.length;r.push({name:i,complexity:e,type:"weighted"})}}),this.conditionalRules.forEach((t,i)=>{if(!e||i===e){const e=3*t.conditions.length;r.push({name:i,complexity:e,type:"conditional"})}}),this.templateRules.forEach((t,i)=>{if(!e||i===e){const e=2*this.findVariables(t.template).length+Object.keys(t.variables).length;r.push({name:i,complexity:e,type:"template"})}});const i=r.reduce((e,t)=>e+t.complexity,0),s=r.length>0?r.reduce((e,t)=>e+this.calculateRuleDepth(t.name),0)/r.length:0;r.sort((e,t)=>t.complexity-e.complexity);const n=r.slice(0,5).map(e=>`${e.name} (${e.type}: ${e.complexity})`);return i>100&&t.push("High total complexity - consider simplifying rules"),s>5&&t.push("Deep rule nesting detected - may impact performance"),r.length>50&&t.push("Large number of rules - consider organizing into groups"),{totalComplexity:i,averageDepth:s,mostComplex:n,suggestions:t}}calculateRuleDepth(e,t=new Set){if(t.has(e))return 0;t.add(e);let r=0;const i=this.grammar[e];if(i)for(const e of i){const i=this.findVariables(e);for(const e of i)if(this.hasRule(e)){const i=1+this.calculateRuleDepth(e,new Set(t));r=Math.max(r,i)}}return t.delete(e),r}getHelpfulError(e,t){const r=e.message;let i=r;const s=[];if(r.includes("Maximum recursion depth")&&(s.push("Try reducing the maxDepth with setMaxDepth()"),s.push("Check for circular references in your grammar rules"),t?.ruleName&&s.push(`The rule '${t.ruleName}' may be causing infinite recursion`)),r.includes("must return an array")&&(s.push("Function rules must return string arrays"),s.push("Check your function rule implementation")),r.includes("Weights must sum to 1.0")&&(s.push("Ensure all weights in weighted rules add up to exactly 1.0"),s.push("Use helper: weights = [0.5, 0.3, 0.2] for three items")),(r.includes("not found")||r.includes("undefined"))&&(s.push("Check that all referenced rules are defined"),s.push("Use validate() method to find missing rules"),t?.text)){const e=this.findVariables(t.text).filter(e=>!this.hasRule(e));e.length>0&&s.push(`Missing rules detected: ${e.join(", ")}`)}if(s.length>0&&(i+="\n\nSuggestions:\n"+s.map(e=>`• ${e}`).join("\n")),t?.text){const e=this.validate();e.isValid||(i+="\n\nValidation Issues:\n",e.missingRules.length>0&&(i+=`• Missing rules: ${e.missingRules.join(", ")}\n`),e.circularReferences.length>0&&(i+=`• Circular references: ${e.circularReferences.join(", ")}\n`))}return i}}class i{constructor(){this.registeredFunctions=new Map,this.parser=new r,this.registerDefaultFunctions()}loadFromJSON(e){try{const t=JSON.parse(e);this.loadFromConfig(t)}catch(e){throw new Error(`Failed to parse JSON: ${e instanceof Error?e.message:"Unknown error"}`)}}loadFromConfig(e){e.settings&&(void 0!==e.settings.maxDepth&&this.parser.setMaxDepth(e.settings.maxDepth),void 0!==e.settings.randomSeed&&this.parser.setRandomSeed(e.settings.randomSeed)),e.modifiers&&this.loadModifiers(e.modifiers);for(const[t,r]of Object.entries(e.rules))this.loadRule(t,r)}loadRule(e,t){switch(t.type){case"static":this.loadStaticRule(e,t);break;case"function":this.loadFunctionRule(e,t);break;case"weighted":this.loadWeightedRule(e,t);break;case"conditional":this.loadConditionalRule(e,t);break;case"sequential":this.loadSequentialRule(e,t);break;case"range":this.loadRangeRule(e,t);break;case"template":this.loadTemplateRule(e,t);break;default:throw new Error(`Unknown rule type: ${t.type}`)}}loadStaticRule(e,t){this.parser.addRule(e,t.values)}loadFunctionRule(e,t){const r=this.registeredFunctions.get(t.functionName);if(!r)throw new Error(`Unknown function: ${t.functionName}`);this.parser.addFunctionRule(e,()=>r.handler(t.parameters||{}))}loadWeightedRule(e,t){this.parser.addWeightedRule(e,t.values,t.weights)}loadConditionalRule(e,t){const r=t.conditions.map(e=>{if("default"in e&&e.default)return{default:e.default};if("if"in e&&"then"in e&&e.if&&e.then)return{if:this.createConditionFunction(e.if),then:e.then};throw new Error("Invalid condition format")});this.parser.addConditionalRule(e,{conditions:r})}loadSequentialRule(e,t){this.parser.addSequentialRule(e,t.values,{cycle:!1!==t.cycle})}loadRangeRule(e,t){this.parser.addRangeRule(e,{min:t.min,max:t.max,step:t.step,type:t.numberType})}loadTemplateRule(e,t){this.parser.addTemplateRule(e,{template:t.template,variables:t.variables})}createConditionFunction(e){return t=>{try{let r=e;return r=r.replace(/context\.(\w+)/g,(e,t)=>`context['${t}']`),new Function("context",`return ${r}`)(t)}catch{return!1}}}loadModifiers(e){e.length}registerFunction(e){this.registeredFunctions.set(e.name,e)}registerDefaultFunctions(){this.registerFunction({name:"randomNumber",description:"Generate a random number within specified range",handler:(e={})=>{const t=e.min||1,r=e.max||100;return[(Math.floor(Math.random()*(r-t+1))+t).toString()]}}),this.registerFunction({name:"diceRoll",description:"Roll dice (e.g., d6, d20)",handler:(e={})=>{const t=e.sides||6,r=e.count||1;let i=0;for(let e=0;e<r;e++)i+=Math.floor(Math.random()*t)+1;return[i.toString()]}}),this.registerFunction({name:"currentTime",description:"Get current time in various formats",handler:(e={})=>{const t=new Date;switch(e.format||"time"){case"time":default:return[t.toLocaleTimeString()];case"date":return[t.toLocaleDateString()];case"datetime":return[t.toLocaleString()]}}}),this.registerFunction({name:"randomChoice",description:"Choose random item from provided array",handler:(e={})=>{const t=e.choices||["option1","option2","option3"];return[t[Math.floor(Math.random()*t.length)]]}})}getParser(){return this.parser}parse(e,t=!1){return this.parser.parse(e,t)}getRegisteredFunctions(){return Array.from(this.registeredFunctions.keys())}validate(){return this.parser.validate()}clear(){this.parser.clearAll()}}class s{constructor(e){this.loader=e}createConditionalRule(e,t){const r={type:"conditional",conditions:[{if:t.if,then:t.then}]};t.else&&r.conditions.push({default:t.else}),this.loader.loadFromConfig({rules:{[e]:r}})}createWeightedRule(e,t){const r={type:"weighted",values:t.values,weights:t.weights};this.loader.loadFromConfig({rules:{[e]:r}})}createRangeRule(e,t){const r={type:"range",min:t.min,max:t.max,step:t.step,numberType:t.type||"integer"};this.loader.loadFromConfig({rules:{[e]:r}})}createTemplateRule(e,t){const r={type:"template",template:t.template,variables:t.variables};this.loader.loadFromConfig({rules:{[e]:r}})}createSequentialRule(e,t){const r={type:"sequential",values:t.sequence,cycle:t.cycle};this.loader.loadFromConfig({rules:{[e]:r}})}createFunctionRule(e,t){const r={type:"function",functionName:t.function,parameters:t.parameters};this.loader.loadFromConfig({rules:{[e]:r}})}loadKeywordConfig(e){const t={rules:{},modifiers:e.modifiers,settings:e.settings};for(const[r,i]of Object.entries(e.rules))t.rules[r]=this.convertKeywordRule(i);this.loader.loadFromConfig(t)}convertKeywordRule(e){if(Array.isArray(e))return{type:"static",values:e};const t=e;if("if"in t&&"then"in t&&t.if&&t.then){const e=[{if:t.if,then:t.then}];return"else"in t&&t.else&&e.push({default:t.else}),{type:"conditional",conditions:e}}if("values"in t&&"weights"in t&&t.values&&t.weights)return{type:"weighted",values:t.values,weights:t.weights};if("min"in t&&"max"in t&&"number"==typeof t.min&&"number"==typeof t.max)return{type:"range",min:t.min,max:t.max,step:t.step,numberType:t.type||"integer"};if("template"in t&&"variables"in t&&t.template&&t.variables)return{type:"template",template:t.template,variables:t.variables};if("sequence"in t&&t.sequence)return{type:"sequential",values:t.sequence,cycle:t.cycle};if("function"in t&&t.function)return{type:"function",functionName:t.function,parameters:t.parameters};throw new Error("Unable to determine rule type from keywords")}}function n(){const e=new i;return{loader:e,builder:new s(e)}}return t})());